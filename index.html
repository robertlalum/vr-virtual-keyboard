<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>WebXR Virtual Keyboard + Pointer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/aframe-extras@6.1.1/dist/aframe-extras.min.js"></script>
  <style>
    body { margin: 0; font-family: sans-serif; }
    #uiHint { position: absolute; left: 12px; top: 12px; z-index: 10; color: white; background: rgba(0,0,0,0.4); padding:8px; border-radius:6px; }
  </style>
</head>
<body>
<div id="uiHint">Open in Meta Quest Browser. Point + trigger to type. Use grip to toggle pointer drag.</div>

<a-scene background="color: #111" vr-mode-ui="enterVRButton: true">
  <!-- Camera + Controllers -->
  <a-entity id="cameraRig">
    <a-entity id="camera" camera look-controls position="0 1.6 0"></a-entity>

    <!-- Right controller raycaster for pointing/typing -->
    <a-entity id="rightHand" laser-controls="hand: right" raycaster="
      objects: .key, .clickable;
      far: 10;
      showLine: true;"
      oculus-touch-controls
      tracked-controls
      vive-controls
      daydream-controls></a-entity>

    <!-- Left controller for optional use -->
    <a-entity id="leftHand" laser-controls="hand: left" raycaster="
      objects: .key, .clickable;
      far: 10;
      showLine: true;"
      oculus-touch-controls
      tracked-controls></a-entity>
  </a-entity>

  <!-- A floating screen for typed text -->
  <a-entity id="screen" position="0 1.6 -1.2">
    <a-plane width="1.6" height="0.6" color="#222" material="shader:flat" position="0 0 0"></a-plane>
    <a-entity id="typedText" position="-0.74 0.18 0.01" text="value: ; color: #fff; width: 2.2; align: left; wrapCount: 45"></a-entity>
    <a-entity id="cursorBlink" geometry="primitive: plane; width:0.01; height:0.04" material="color: #fff" position="0.72 -0.18 0.01" visible="false"></a-entity>
  </a-entity>

  <!-- Keyboard parent -->
  <a-entity id="keyboard" position="0 1.25 -1.2"></a-entity>

  <!-- Pointer dot for mouse emulation (center) -->
  <a-sphere id="pointerDot" radius="0.01" position="0 1.55 -0.9" visible="false"></a-sphere>

  <!-- Floor just for reference -->
  <a-plane rotation="-90 0 0" width="10" height="10" color="#0b0b0b" position="0 0 -2"></a-plane>

  <a-entity light="type: ambient; intensity: 0.5"></a-entity>
  <a-entity light="type: directional; intensity: 0.7" position="-1 2 1"></a-entity>
</a-scene>

<script>
/*
  WebXR Virtual Keyboard + Pointer
  - Click keys (class 'key') with controller's trigger (raycaster intersects + 'click' event)
  - Sends events to WebSocket if configured (wsUrl)
  - Mouse emulation: drag (Grip down toggles drag mode) sends pointer move & click events
*/

// CONFIG: WebSocket address (put wss://your-host for secure websocket when serving via HTTPS)
// If you do not want PC injection yet, leave as null
const wsUrl = null; // e.g., "wss://abc123.ngrok.io" or null to disable

let ws = null;
if (wsUrl) {
  ws = new WebSocket(wsUrl);
  ws.onopen = () => console.log('WS connected to', wsUrl);
  ws.onclose = () => console.log('WS closed');
  ws.onerror = (e) => console.warn('WS error', e);
  ws.onmessage = (m) => console.log('WS msg', m.data);
}

// Keyboard layout (simple)
<!-- VR Keyboard Container -->
<div id="vrKeyboard" style="position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%); display: flex; flex-direction: column; gap: 5px;">

  <!-- Text Box -->
  <textarea id="textBox" rows="3" cols="40" placeholder="Type here..." style="font-size: 1.5em;"></textarea>

  <!-- Row 1: Numbers -->
  <div class="keyRow" style="display: flex; gap: 5px;">
    <button class="key" data-key="1">1</button>
    <button class="key" data-key="2">2</button>
    <button class="key" data-key="3">3</button>
    <button class="key" data-key="4">4</button>
    <button class="key" data-key="5">5</button>
    <button class="key" data-key="6">6</button>
    <button class="key" data-key="7">7</button>
    <button class="key" data-key="8">8</button>
    <button class="key" data-key="9">9</button>
    <button class="key" data-key="0">0</button>
  </div>

  <!-- Row 2: Q–P -->
  <div class="keyRow" style="display: flex; gap: 5px;">
    <button class="key" data-key="q">Q</button>
    <button class="key" data-key="w">W</button>
    <button class="key" data-key="e">E</button>
    <button class="key" data-key="r">R</button>
    <button class="key" data-key="t">T</button>
    <button class="key" data-key="y">Y</button>
    <button class="key" data-key="u">U</button>
    <button class="key" data-key="i">I</button>
    <button class="key" data-key="o">O</button>
    <button class="key" data-key="p">P</button>
  </div>

  <!-- Row 3: A–L -->
  <div class="keyRow" style="display: flex; gap: 5px; margin-left: 25px;">
    <button class="key" data-key="a">A</button>
    <button class="key" data-key="s">S</button>
    <button class="key" data-key="d">D</button>
    <button class="key" data-key="f">F</button>
    <button class="key" data-key="g">G</button>
    <button class="key" data-key="h">H</button>
    <button class="key" data-key="j">J</button>
    <button class="key" data-key="k">K</button>
    <button class="key" data-key="l">L</button>
  </div>

  <!-- Row 4: Z–M -->
  <div class="keyRow" style="display: flex; gap: 5px; margin-left: 50px;">
    <button class="key" data-key="z">Z</button>
    <button class="key" data-key="x">X</button>
    <button class="key" data-key="c">C</button>
    <button class="key" data-key="v">V</button>
    <button class="key" data-key="b">B</button>
    <button class="key" data-key="n">N</button>
    <button class="key" data-key="m">M</button>
    <button class="key" data-key="backspace">⌫</button>
  </div>

  <!-- Row 5: Space, Enter, Basic Symbols -->
  <div class="keyRow" style="display: flex; gap: 5px; margin-left: 25px;">
    <button class="key" data-key=" " style="width: 200px;">Space</button>
    <button class="key" data-key="enter">Enter</button>
    <button class="key" data-key="!">!</button>
    <button class="key" data-key="@">@</button>
    <button class="key" data-key="#">#</button>
    <button class="key" data-key="$">$</button>
  </div>
</div>

<!-- Keyboard JS -->
<script>
  const keys = document.querySelectorAll('.key');

  keys.forEach(key => {
    key.addEventListener('click', () => {
      const value = key.dataset.key;
      const textarea = document.querySelector('#textBox');
      const start = textarea.selectionStart;
      const end = textarea.selectionEnd;

      if(value === 'backspace') {
        textarea.value = textarea.value.slice(0, start-1) + textarea.value.slice(end);
        textarea.selectionStart = textarea.selectionEnd = start-1;
      } else if(value === 'enter') {
        textarea.value = textarea.value.slice(0, start) + "\n" + textarea.value.slice(end);
        textarea.selectionStart = textarea.selectionEnd = start+1;
      } else {
        textarea.value = textarea.value.slice(0, start) + value + textarea.value.slice(end);
        textarea.selectionStart = textarea.selectionEnd = start + value.length;
      }

      textarea.focus();
    });
  });
</script>


AFRAME.registerComponent('key-pressable', {
  init: function () {
    // On click via the controller raycaster
    this.el.addEventListener('click', (evt) => {
      const k = this.el.getAttribute('data-key');
      handleKey(k);
      // animate
      this.el.setAttribute('scale','0.95 0.95 0.95');
      setTimeout(()=> this.el.setAttribute('scale','1 1 1'),80);
    });
  }
});

// Create keyboard
function createKeyboard() {
  const parent = document.getElementById('keyboard');
  const startX = -0.7;
  const keyW = 0.14;
  const keyH = 0.12;
  const rowGap = 0.015;
  layout.forEach((row, rowIndex) => {
    const y = 0.02 - rowIndex * (keyH + rowGap);
    let rowWidth = row.length * (keyW + 0.01);
    let x = startX + (1.0 - rowWidth) / 2 + rowIndex*0.02;
    row.forEach((k) => {
      const w = (k === 'Space') ? (keyW*5+0.04) : (k === 'Enter' ? keyW*1.7 : keyW);
      const el = document.createElement('a-entity');
      el.setAttribute('geometry', `primitive: plane; width: ${w}; height: ${keyH}`);
      el.setAttribute('material', 'color: #333; shader: flat');
      el.setAttribute('position', `${x + w/2} ${y} 0`);
      el.setAttribute('rotation', '-30 0 0'); // tilt toward user
      el.setAttribute('class', 'key');
      el.setAttribute('data-key', k);
      el.setAttribute('key-pressable', '');
      const label = document.createElement('a-entity');
      label.setAttribute('text', `value: ${k}; align: center; width: 2; color: #fff`);
      label.setAttribute('position', '0 0 0.01');
      label.setAttribute('rotation', '0 0 0');
      el.appendChild(label);
      parent.appendChild(el);
      x += w + 0.01;
    });
  });
}
createKeyboard();

// typed text buffer
let buffer = '';
const typedText = document.getElementById('typedText');
function updateScreen() {
  typedText.setAttribute('text', 'value', buffer);
  // send to WS
  if (ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({type:'textUpdate', text: buffer}));
  }
}

// handle key press
function handleKey(k) {
  if (k === 'Back') {
    buffer = buffer.slice(0, -1);
  } else if (k === 'Space') {
    buffer += ' ';
  } else if (k === 'Enter') {
    buffer += '\n';
  } else {
    buffer += k;
  }
  updateScreen();
  if (ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({type:'key', key: k}));
  }
}

// Pointer / mouse emulation:
const rightHand = document.getElementById('rightHand');
const leftHand = document.getElementById('leftHand');
const pointerDot = document.getElementById('pointerDot');

function handleRayIntersect(evt) {
  const el = evt.detail.intersectedEl;
  if (!el) return;
  const point = evt.detail.intersection.point;
  pointerDot.setAttribute('position', `${point.x} ${point.y} ${point.z}`);
  pointerDot.setAttribute('visible', true);
  if (dragging) {
    sendPointerMove(point);
  }
}

rightHand.addEventListener('raycaster-intersection', handleRayIntersect);
leftHand.addEventListener('raycaster-intersection', handleRayIntersect);

function handleRayLeave() {
  pointerDot.setAttribute('visible', false);
}
rightHand.addEventListener('raycaster-intersection-cleared', handleRayLeave);
leftHand.addEventListener('raycaster-intersection-cleared', handleRayLeave);

// Send pointer move (normalized to screen)
function sendPointerMove(point) {
  const screen = document.getElementById('screen');
  const inv = new THREE.Matrix4().getInverse(screen.object3D.matrixWorld);
  const p = new THREE.Vector3(point.x, point.y, point.z).applyMatrix4(inv);
  const nx = (p.x + 0.8) / 1.6; // 0..1
  const ny = (0.3 - p.y) / 0.6; // 0..1 from top
  const cx = Math.max(0, Math.min(1, nx));
  const cy = Math.max(0, Math.min(1, ny));
  if (ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({type:'pointerMove', x: cx, y: cy}));
  }
}

let dragging = false;
function setupGripToggle(handEl) {
  handEl.addEventListener('gripdown', () => { dragging = true; console.log('dragging ON'); });
  handEl.addEventListener('gripup', () => { dragging = false; console.log('dragging OFF'); });
  handEl.addEventListener('triggerdown', () => {
    const pos = pointerDot.getAttribute('position');
    if (pointerDot.getAttribute('visible')) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({type:'pointerClick', x: pos.x, y: pos.y, z: pos.z}));
      }
    }
  });
}
setupGripToggle(rightHand);
setupGripToggle(leftHand);

// small blink cursor for the typed text
setInterval(() => {
  const blink = document.getElementById('cursorBlink');
  blink.setAttribute('visible', !blink.getAttribute('visible'));
}, 500);

// initial update
updateScreen();

</script>
</body>
</html>
