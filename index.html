<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>WebXR Virtual Keyboard + Pointer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/aframe-extras@6.1.1/dist/aframe-extras.min.js"></script>
  <style>
    body { margin: 0; font-family: sans-serif; }
    #uiHint { position: absolute; left: 12px; top: 12px; z-index: 10; color: white; background: rgba(0,0,0,0.4); padding:8px; border-radius:6px; }
  </style>
</head>
<body>
<div id="uiHint">Open in Meta Quest Browser. Point + trigger to type. Use grip to toggle pointer drag.</div>

<a-scene background="color: #111" vr-mode-ui="enterVRButton: true">
  <!-- Camera + Controllers -->
  <a-entity id="cameraRig">
    <a-entity id="camera" camera look-controls position="0 1.6 0"></a-entity>

    <!-- Right controller raycaster for pointing/typing -->
    <a-entity id="rightHand" laser-controls="hand: right" raycaster="
      objects: .key, .clickable;
      far: 10;
      showLine: true;"
      oculus-touch-controls
      tracked-controls
      vive-controls
      daydream-controls></a-entity>

    <!-- Left controller for optional use -->
    <a-entity id="leftHand" laser-controls="hand: left" raycaster="
      objects: .key, .clickable;
      far: 10;
      showLine: true;"
      oculus-touch-controls
      tracked-controls></a-entity>
  </a-entity>

  <!-- A floating screen for typed text -->
  <a-entity id="screen" position="0 1.6 -1.2">
    <a-plane width="1.6" height="0.6" color="#222" material="shader:flat" position="0 0 0"></a-plane>
    <!-- Text positioned at top-left, inside the text box -->
    <a-entity id="typedText" position="-0.4 0.2 0.01" text="value: ; color: #fff; width: 1.0; align: left; wrapCount: 15; baseline: top; fontSize: 48"></a-entity>
    <!-- Cursor positioned next to text -->
    <a-entity id="cursorBlink" geometry="primitive: plane; width:0.008; height:0.035" material="color: #fff; emissive: #fff" position="-0.7 0.2 0.01" visible="false"></a-entity>
  </a-entity>

  <!-- Keyboard parent -->
  <a-entity id="keyboard" position="0 1.25 -1.2"></a-entity>

  <!-- Pointer dot for mouse emulation (center) -->
  <a-sphere id="pointerDot" radius="0.01" position="0 1.55 -0.9" visible="false"></a-sphere>

  <!-- Floor just for reference -->
  <a-plane rotation="-90 0 0" width="10" height="10" color="#0b0b0b" position="0 0 -2"></a-plane>

  <a-entity light="type: ambient; intensity: 0.5"></a-entity>
  <a-entity light="type: directional; intensity: 0.7" position="-1 2 1"></a-entity>
</a-scene>

<script>
/*
  WebXR Virtual Keyboard + Pointer
  - Click keys (class 'key') with controller's trigger (raycaster intersects + 'click' event)
  - Sends events to WebSocket if configured (wsUrl)
  - Mouse emulation: drag (Grip down toggles drag mode) sends pointer move & click events
*/

// CONFIG: WebSocket address (put ws://<PC_IP>:3000 for testing)
const wsUrl = null; // e.g., "ws://192.168.1.40:3000" or null to disable

let ws = null;
if (wsUrl) {
  ws = new WebSocket(wsUrl);
  ws.onopen = () => console.log('WS connected to', wsUrl);
  ws.onclose = () => console.log('WS closed');
  ws.onerror = (e) => console.warn('WS error', e);
  ws.onmessage = (m) => console.log('WS msg', m.data);
}

// Keyboard layout (simple)
const layout = [
  ['q','w','e','r','t','y','u','i','o','p'],
  ['a','s','d','f','g','h','j','k','l'],
  ['z','x','c','v','b','n','m','Back'],
  ['Space','Enter']
];

AFRAME.registerComponent('key-pressable', {
  init: function () {
    // On click via the controller raycaster
    this.el.addEventListener('click', (evt) => {
      const k = this.el.getAttribute('data-key');
      handleKey(k);
      // animate
      this.el.setAttribute('scale','0.95 0.95 0.95');
      setTimeout(()=> this.el.setAttribute('scale','1 1 1'),80);
    });
  }
});

// Create keyboard
function createKeyboard() {
  const parent = document.getElementById('keyboard');
  const startX = -0.7;
  const keyW = 0.14;
  const keyH = 0.12;
  const rowGap = 0.015;
  layout.forEach((row, rowIndex) => {
    const y = 0.02 - rowIndex * (keyH + rowGap);
    let rowWidth = row.length * (keyW + 0.01);
    let x = startX + (1.0 - rowWidth) / 2 + rowIndex*0.02;
    row.forEach((k) => {
      const w = (k === 'Space') ? (keyW*5+0.04) : (k === 'Enter' ? keyW*1.7 : keyW);
      const el = document.createElement('a-entity');
      el.setAttribute('geometry', `primitive: plane; width: ${w}; height: ${keyH}`);
      el.setAttribute('material', 'color: #333; shader: flat');
      el.setAttribute('position', `${x + w/2} ${y} 0`);
      el.setAttribute('rotation', '-30 0 0'); // tilt toward user
      el.setAttribute('class', 'key');
      el.setAttribute('data-key', k);
      el.setAttribute('key-pressable', '');
      const label = document.createElement('a-entity');
      label.setAttribute('text', `value: ${k}; align: center; width: 2; color: #fff`);
      label.setAttribute('position', '0 0 0.01');
      label.setAttribute('rotation', '0 0 0');
      el.appendChild(label);
      parent.appendChild(el);
      x += w + 0.01;
    });
  });
}
createKeyboard();

// typed text buffer
let buffer = '';
const typedText = document.getElementById('typedText');
const cursorBlink = document.getElementById('cursorBlink');

function updateScreen() {
  typedText.setAttribute('text', 'value', buffer);
  // Position cursor right after the text (approximate character width)
  const charWidth = 0.03;
  const cursorX = -0.4 + (buffer.length * charWidth);
  cursorBlink.setAttribute('position', `${cursorX} 0.2 0.01`);
  
  // send to WS
  if (ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({type:'textUpdate', text: buffer}));
  }
}

// handle key press
function handleKey(k) {
  if (k === 'Back') {
    buffer = buffer.slice(0, -1);
  } else if (k === 'Space') {
    buffer += ' ';
  } else if (k === 'Enter') {
    buffer += '\n';
  } else {
    buffer += k;
  }
  updateScreen();
  if (ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({type:'key', key: k}));
  }
}

// Pointer / mouse emulation:
// - Toggle pointer mode when user presses primary button on controller (grip to drag).
// We'll listen for controllerbutton events from A-Frame (gamepad events aren't uniform everywhere,
// but the raycaster 'click' is reliable for clicking keys).
// For pointer moves, we'll show a small dot at the intersection point when ray hits any clickable surface.

const rightHand = document.getElementById('rightHand');
const leftHand = document.getElementById('leftHand');
const pointerDot = document.getElementById('pointerDot');

function handleRayIntersect(evt) {
  const el = evt.detail.intersectedEl;
  if (!el) return;
  // Show pointer at intersection point
  const point = evt.detail.intersection.point;
  pointerDot.setAttribute('position', `${point.x} ${point.y} ${point.z}`);
  pointerDot.setAttribute('visible', true);

  // If in drag mode (grip pressed) we send pointer move events
  if (dragging) {
    sendPointerMove(point);
  }
}

rightHand.addEventListener('raycaster-intersection', handleRayIntersect);
leftHand.addEventListener('raycaster-intersection', handleRayIntersect);

// Hide pointer when no intersection
function handleRayLeave() {
  pointerDot.setAttribute('visible', false);
}
rightHand.addEventListener('raycaster-intersection-cleared', handleRayLeave);
leftHand.addEventListener('raycaster-intersection-cleared', handleRayLeave);

// Send pointer move (normalized to screen)
function sendPointerMove(point) {
  // Map 3D point on keyboard/screen plane to local coords relative to screen entity
  const screen = document.getElementById('screen');
  const inv = new THREE.Matrix4().getInverse(screen.object3D.matrixWorld);
  const p = new THREE.Vector3(point.x, point.y, point.z).applyMatrix4(inv);
  // screen plane is width 1.6 x height 0.6 centered at 0,0,0
  const nx = (p.x + 0.8) / 1.6; // 0..1
  const ny = (0.3 - p.y) / 0.6; // 0..1 from top
  // clamp
  const cx = Math.max(0, Math.min(1, nx));
  const cy = Math.max(0, Math.min(1, ny));
  if (ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({type:'pointerMove', x: cx, y: cy}));
  }
}

// Dragging state toggled with grip press (gamepad button 2 typical). We'll listen for controllerbutton events
let dragging = false;
function setupGripToggle(handEl) {
  // A-Frame exposes controller events like 'gripdown' and 'gripup' on controller entities
  handEl.addEventListener('gripdown', () => { dragging = true; console.log('dragging ON'); });
  handEl.addEventListener('gripup', () => { dragging = false; console.log('dragging OFF'); });
  // primary click to send pointer click
  handEl.addEventListener('triggerdown', () => {
    // send pointer click at current pointerDot position
    const pos = pointerDot.getAttribute('position');
    if (pointerDot.getAttribute('visible')) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({type:'pointerClick', x: pos.x, y: pos.y, z: pos.z}));
      }
    }
  });
}
setupGripToggle(rightHand);
setupGripToggle(leftHand);

// small blink cursor for the typed text
setInterval(() => {
  cursorBlink.setAttribute('visible', !cursorBlink.getAttribute('visible'));
}, 500);

// initial update
updateScreen();

</script>
</body>
</html>
